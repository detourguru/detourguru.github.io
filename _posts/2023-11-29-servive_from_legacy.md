---
layout: post
title: 스파게티에서 살아남기 
subtitle: 레거시 코드와 리팩토링
cover-img: /assets/img/pasta.jpg
thumbnail-img: /assets/img/pasta.jpg
share-img: /assets/img/
tags: [Legacy, Refactoring]
author: Detourguru
---
# 레거시 코드의 재생성
지금 다니는 회사에는 막대한 양의 레거시 코드가 있다. 그 이유에는 몇 가지가 있는데, 개인적으로는 레거시 코드를 만들기 위한 101가지 방법이라는 책을 써도 될 정도이다.

그 중 세 가지를 추려보자면 아래와 같다:

### 특정 고객사만을 위한 기능
그런 얘기가 돈다. _S업체는 사실 우리 서비스를 쓰는게 아니다. S업체 전용 서비스를 쓰는 것이다,_ 라고.
사실 이해는 한다. 우리 회사는 B2B 서비스를 제공하고 있고, 경쟁사가 많은 포화된 시장에서 차별화를 위한 가장 빠른 전략이었을 것이다. 하지만 미비한 위키와 떠나버린 초기 개발자들이라는 변수까지 만나게 된다면? 유지보수하는 개발자들 입장에서는 비명이 절로 나오는 일이다.


> 농담처럼 나오는 `var1`, `var2`가 실존하는 변수명이라면 누가 믿을까? 심지어는 함수명까지도 `function1()`, `function2()`였다. 주석이라도 있으면 좋았겠지만.. 변수, 함수명에도 고민을 한 흔적이 없는데 주석을 달았을까? 


더 슬픈 것은 업체명이 박힌 코드는 늘어만 가는데, 이 코드가 왜, 무엇을 위해 작성되었는지는 남지 않았다는 것이다. 팀도, 업체도 왜 그 코드가 있는지 모른다. _'그럼, 없애주세요.'_ 다시 봐도 딱히 특이사항이 없는 코드라서 무심코 삭제하면, 무수한 에러 로그에서 깨달음이 온다. 아, 이 데이터 때문이었구나.

### 언어의 특수성
레거시 프로젝트의 개발 언어는 이미 업데이트가 종료된, 사장된 언어다. 지원하지 않는 기능이 너무 많아 일일히 풀어 써야하기 때문에 코드가 더럽기 짝이 없다. 동일한 기능을 하는 같은 함수가 각 페이지에 서로 다른 로직으로 산개되어있고, 코드의 양은 방대하다. 여러모로 유지보수성과는 거리가 먼 셈이다. 그나마 나오는 블로그들도 모두 2010년대 초반 글 뿐... 유지보수라곤 고려조차 않은 듯한 코드가 무수한데 거기서 에러가 난다면... 처음부터 끝까지 응답을 찍어보며 디버깅하는 수밖에 없다.

### 부족한 비용과 보수적인 고객사
모두가 레거시 프로젝트의 문제점을 안다. 서서히 새로운 언어로 리팩토링을 시작한다. 그때 결정권자가 무심코 말씀하시길, _'이게 정말 필요한거야? 비용적인 면을 생각해봐.'_ 싹 갈아 엎겠다는 원대한 팀의 계획은 무너지고 코드의 개선이 아닌 말 그대로의 언어의 이전만이 이루어진다. 

게다가 보수적인 고객사들은 사소한 변화라도 좋아하지 않기 때문에 하위호환성은 당연하게 보장되어야한다. 버릴 것은 버리고 옮겨가야겠지만... 단 하나만의 고객사를 위한 코드까지 모두 이전되야하기 때문에 특정 고객사만을 위한 기능도 그렇게 옮겨간다. 커스텀하게 제공되던 데이터도 당연히 옮겨가야한다. 레거시 코드의 재생성이 시작된다.

# 스파게티에서 살아남기
불만 불평은 여기까지. 어차피 나의 업무이기 때문에 그럼에도 불구하고 레거시 코드의 리팩토링을 포기할 수는 없다. 장기적으로는 더욱 고비용이 들기 때문이다. 나는 우리 회사의 숙원사업을 하나 맡게 되었는데, 바로 레거시 코드로 작성된 판매처 연동 코드를 새로운 프로젝트로 옮겨가는 것이었다.

새로 만들었으면 만들었지, 기존 기능은 유지하면서 개선된 코드를 작성하는건 꽤나 복잡한 일이다. 특히나 변동이 생긴 데이터라도 있으면 더욱 어려워진다.

많은 개발자들이 무수한 리팩토링 전략에 대해 소개한다. 이것은 그 중의 하나이다. 정답도, 방법론도 아닌 내가 해온 방식이다.

### 옮겨야할 기능의 명세서화
너무나 당연한 이야기다. 내가 무슨 기능을 옮겨야하는지 부터 파악해야한다. 어떻게 파악할 수 있을까? 코드를 따라가기 보다는 처음에는 비즈니스 로직을 따라가는 것이 편하다. 모르는 기능은 기획이나 QA팀에게 물어본다.

그리고 살펴본다. 프론트에 무슨 버튼이 있고, 무슨 인풋창이 있는가? 각각은 무슨 데이터를 넘겨주는가? 그 데이터는 어디로 가는가? 디테일한 내용은 이 단계에서 필요하지 않다. 우리가 필요한 것은 기능의 목록이다. 

그래서 이 코드가 반환하는 최종적인 응답은 어떻게 생겼는가? 무슨 데이터를 포함하고, 어떻게 가공해주는가? 내가 내어주어야 할 응답도 모른채 개발을 하는 사람은 없을 것이다.

물론 불필요하게 많은 depth의 if 조건문들, 불필요하게 복잡한 raw 쿼리로 이루어진 레거시 코드 안에서 길을 잃을 수도 있다. 하지만 침착하고, 심호흡하고, 하나하나 명세서화 해간다. 값을 받아서, 이 조건 아래에서 이렇게 처리한다. 

레거시 코드는 상상 이상의 비밀을 감추고 있는 경우가 많다. 그 비밀에서 하나하나 발라내는 재미가 또 은근히 무엇에도 비할 수 없는 쾌감이 된다. 아, 내부 API가 있다면 얼마나 편할까! 하지만 세상이 그렇게 호락호락하지 않다. 그래도 괜찮다. 내가 작성하면 되니까. 많은 후발주자들이 고마워하는 존재가 되는 것이다.

### 테스트코드 작성
코드가 반환한 응답의 형식을 먼저 받아보고, 테스트코드를 작성한다. 나는 이런 데이터를 넘겨줄텐데, 너는 이런 처리를 해야해, 하고 알려주어야한다. 이 테스트코드가 나의 지표가 된다. 내가 잘못된 데이터를 내어주더라도 길을 잃지 않게 도와주는 이정표가 될 것이다.

테스트코드는 기능 단위로 작성하고, 오류 케이스마다 목업 데이터를 가지고 오류 케이스의 테스트코드를 작성한다. 은근히 테스트코드를 작성하다가 로직의 이상함을 눈치채는 경우가 많다. 테스트 주도 개발, TDD가 많은 개발자들의 이정표가 되는 이유가 있다.


# 결론
레거시는 누구나 싫어한다. 하지만 옮기지 않을 수는 없고, 어차피 해야하는 일이라면 후발주자에게 도움이 되는 방향으로 진행하면 더욱 좋을 것이다. 나는 레거시 코드의 리팩토링이 지루하면서도 좋았다. 회사의 숙원사업을 청산하고, 불필요한 코드를 덜고, 쿼리 튜닝으로 성능을 개선하면 더욱 좋다.

어차피 유지보수는 나와 내 팀의 몫이다. 어차피 나도 나중에 나의 도움을 받게 되어있다. 레거시를 증오하지 말자!