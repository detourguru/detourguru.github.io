---
layout: post
title: Transaction과 ACID
subtitle: 
cover-img: /assets/img/atm.png
thumbnail-img: /assets/img/atm.png
share-img: /assets/img/atm.png
tags: [DB]
author: Detourguru
---

# 목차
[1. Transaction](#transaction)

[2. ACID](#acid)

# Transaction
트랜잭션이란 작업의 한 단위로, 원자 처럼 쪼갤 수 없는 최소 단위를 의미한다. 

최소 단위라는 것은 이 작업을 분할해서 진행하거나 하나의 작업 중 다른 작업이 끼어들어서는 안된다는 의미를 내포하고 있다.

따라서 트랜잭션에는 commit(전달), rollback(복구) 기능이 수반되어야한다.

작업이 성공을 했을 때는 commit으로 변조된 데이터를 전달(저장)해주고, 실패를 했을 때에는 rollback으로 변조된 데이터를 되돌려야하기 때문이다.

# ACID
트랜잭션이 준수해야하는 특징으로는 ACID를 들어 설명할 수 있다.

## A: 원자성 Atomicity
> 하나의 트랜잭션은 원자와 같이 더이상 쪼갤 수 없는 최소 단위를 유지해야한다.

ATM에서 출금을 요청한다 했을 때 아래와 같은 일련의 작업들이 일어날 수 있다.
1. 카드 정보 확인
2. 내 잔고에서 차감
3. 은행사에서 요청과 차감 이력 기록
4. ATM에서도 차감

중간에 에러가 났을 때 변조된 데이터 중 하나라도 복구되지 않으면 나는 잔고를 잃을 잃을 것이고, 은행과 ATM은 신뢰를 잃을 것이다.

원자성이란 이처럼 일련의 과정 중 모든 작업이 정상적으로 처리 된 경우에만 커밋해야한다는 원칙이다. 마치 연좌제처럼, 일련의 과정 중 하나의 작업이 문제가 되었다 하더라도 그 작업은 작업 전과 같은 상태로 롤백 되어야한다.

## C: 일관성 Consistency
> 트랜잭션 후에도 DB 내의 데이터는 일관성을 유지해야한다.

ATM으로 출금하기 전의 내 잔고가 만약 4,000원이었다고 가정했을 때, 처리를 하고 나서 갱신된 금액이 갑자기 '사천원'으로 입력된다면 어떨까?
데이터에 일관성이 없을 뿐만 아니라 어떤 에러를 야기할지조차 짐작할 수 없다.

이처럼 트랜잭션은 DB의 제약조건을 준수해야한다.

## I: 격리성 Isolation
> 각 트랜잭션은 서로를 간섭할 수 없다.

만약 내가 실물카드와 앱카드를 가지고 서로 다른 ATM 두 대에 각각 출금 요청을 했다고 가정해보자.
잔고가 4000원인데 두 ATM에서 동시에 각 4000원 씩 출금 요청을 했을 때 둘 중 한 대에서는 잔고가 없다는 에러를 반환해야한다. 내 잔고는 4000원이지 8000원이 아니기 때문이다. 4천원씩 도합 8천원을 출금할 수 있도록 두어서는 안된다.

트랜잭션이 걸려있다면 이러한 현상을 방지할 수 있을 것이다. 이것이 격리성의 특징이다.

## D: 지속성 Durability
> 성공적으로 처리되어 커밋된 데이터는 지속적으로 유지되어야한다.

4천원을 출금 요청 해서 성공적으로 잔고에서 4천원을 차감하고, 출금이 되었다면 내가 4천원을 출금했다는 데이터는 은행 서버가 죽더라도 남아있어야하며 복구되어서는 안된다.

은행 서버가 죽었다고 내가 출금을 했다는 데이터가 휘발 된다면 은행은 금새 파산할 것이다.


# 결론
트랜잭션은 DB의 데이터를 변조하거나 추가할 때 일관성을 유지하기 위해 필요하며,
ACID를 준수하여 트랜잭션을 적절히 활용하면 데이터가 중복되거나 일부만 저장되어 무결성이 깨지는 케이스가 발생할 가능성이 현저히 적어질 수 있다.